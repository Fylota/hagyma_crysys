using System.Diagnostics.CodeAnalysis;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Drawing.Imaging;
using System.Runtime.InteropServices;

namespace Backend.Helpers;

using SysColor = Color;

[SuppressMessage("Interoperability", "CA1416:Validate platform compatibility", Justification = "<Pending>")]
// Helper class found on the internet to convert images from ppm to a more common image type
public class PixelMap
{
    private PixelMapHeader _header;

    /// <summary>
    ///     Stream-based constructor. Typically, the stream will be a FileStream, but it may also be a MemoryStream
    ///     or other object derived from the Stream class.
    /// </summary>
    /// <param name="stream">A stream containing the header and data portions of the .pbm, .pgm, or .ppm image.</param>
    public PixelMap(Stream stream)
    {
        FromStream(stream);
    }

    /// <summary>
    ///     The Bitmap created from the PixelMap.
    /// </summary>
    public Bitmap BitMap { get; private set; } = null!;


    /// <summary>
    ///     The data portion of the PixelMap.
    /// </summary>
    private byte[] ImageData { get; set; } = null!;

    /// <summary>
    ///     The number of bytes per pixel.
    /// </summary>
    private int BytesPerPixel { get; set; }

    /// <summary>
    ///     The stride of the scan across the image.  Typically this is width * bytesPerPixel, and is a multiple of 4.
    /// </summary>
    private int Stride { get; set; }

    /// <summary>
    ///     The pixel format used by the BitMap generated by this PixelMap.
    /// </summary>
    private PixelFormat PixelFormat { get; set; }

    /// <summary>
    ///     The header portion of the PixelMap.
    /// </summary>
    public PixelMapHeader Header
    {
        get => _header;
        set => _header = value;
    }

    private Bitmap CreateBitMap()
    {
        var pImageData = Marshal.AllocHGlobal(ImageData.Length);
        Marshal.Copy(ImageData, 0, pImageData, ImageData.Length);
        var bitmap = new Bitmap(_header.Width, _header.Height, Stride, PixelFormat, pImageData);
        return bitmap;
    }

    /// <summary>
    ///     This method is able to handle the process of creating Bitmaps that are not sized in widths that are multiples
    ///     of 4 pixels (which is needed for the rapid drawing using the Marshal class.)  Unfortunately, this is a very slow
    ///     method, since it uses SetPixel().
    /// </summary>
    /// <returns></returns>
    private Bitmap CreateBitmapOffSize()
    {
        var bitmap = new Bitmap(_header.Width, _header.Height, PixelFormat.Format24bppRgb);
        var sysColor = new SysColor();
        int red, green, blue, grey;
        int index;

        for (var x = 0; x < _header.Width; x++)
        for (var y = 0; y < _header.Height; y++)
        {
            index = x + y * _header.Width;

            switch (_header.MagicNumber)
            {
                case "P6":
                    index = 3 * index;
                    blue = ImageData[index];
                    green = ImageData[index + 1];
                    red = ImageData[index + 2];
                    sysColor = SysColor.FromArgb(red, green, blue);
                    break;
                default:
                    throw new NotImplementedException();
            }

            bitmap.SetPixel(x, y, sysColor);
        }

        return bitmap;
    }

    public static Bitmap ResizeImage(Image image, int maxSize)
    {
        int width, height;
        if (image.Height < image.Width)
        {
            width = maxSize;
            height = (int) Math.Round(maxSize * ((float) image.Height / image.Width));
        }
        else
        {
            height = maxSize;
            width = (int) Math.Round(maxSize * ((float) image.Width / image.Height));
        }

        var destRect = new Rectangle(0, 0, width, height);
        var destImage = new Bitmap(width, height);

        destImage.SetResolution(image.HorizontalResolution, image.VerticalResolution);

        using var graphics = Graphics.FromImage(destImage);
        graphics.CompositingMode = CompositingMode.SourceCopy;
        graphics.CompositingQuality = CompositingQuality.HighQuality;
        graphics.InterpolationMode = InterpolationMode.HighQualityBicubic;
        graphics.SmoothingMode = SmoothingMode.HighQuality;
        graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;

        using var wrapMode = new ImageAttributes();
        wrapMode.SetWrapMode(WrapMode.TileFlipXY);
        graphics.DrawImage(image, destRect, 0, 0, image.Width, image.Height, GraphicsUnit.Pixel, wrapMode);

        return destImage;
    }

    private int ReadValue(BinaryReader binReader)
    {
        var value = string.Empty;
        while (!char.IsWhiteSpace((char) binReader.PeekChar())) value += binReader.ReadChar().ToString();
        binReader.ReadByte();
        return int.Parse(value);
    }

    private void FromStream(Stream stream)
    {
        _header = new PixelMapHeader();
        var headerItemCount = 0;
        var binReader = new BinaryReader(stream);
        try
        {
            while (headerItemCount < 4)
            {
                var nextChar = (char) binReader.PeekChar();
                if (nextChar == '#') // comment
                    while (binReader.ReadChar() != '\n')
                    {
                    }
                else if (char.IsWhiteSpace(nextChar))
                    binReader.ReadChar();
                else
                    switch (headerItemCount)
                    {
                        case 0: // next item is Magic Number
                            // Read the first 2 characters and determine the type of pixelmap.
                            var chars = binReader.ReadChars(2);
                            _header.MagicNumber = chars[0] + chars[1].ToString();
                            headerItemCount++;
                            break;
                        case 1: // next item is the width.
                            _header.Width = ReadValue(binReader);
                            headerItemCount++;
                            break;
                        case 2: // next item is the height.
                            _header.Height = ReadValue(binReader);
                            headerItemCount++;
                            break;
                        case 3: // next item is the depth.
                            _header.Depth = ReadValue(binReader);
                            headerItemCount++;
                            break;
                        default:
                            throw new Exception("Error parsing the file header.");
                    }
            }

            switch (_header.MagicNumber)
            {
                case "P6": // 3 bytes per pixel
                    PixelFormat = PixelFormat.Format24bppRgb;
                    BytesPerPixel = 3;
                    break;
                default:
                    throw new Exception("Unknown Magic Number: " + _header.MagicNumber);
            }

            ImageData = new byte[_header.Width * _header.Height * BytesPerPixel];
            Stride = _header.Width * BytesPerPixel;
            var bytesLeft = (int) (binReader.BaseStream.Length - binReader.BaseStream.Position);
            ImageData = binReader.ReadBytes(bytesLeft);
            ReorderBGRtoRGB();
            BitMap = Stride % 4 == 0 ? CreateBitMap() : CreateBitmapOffSize();
            BitMap.RotateFlip(RotateFlipType.Rotate180FlipNone);
        }

        catch (EndOfStreamException e)
        {
            Console.WriteLine(e.Message);
            throw new Exception("Error reading the stream! ", e);
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex.Message);
            throw new Exception("Error reading the stream! ", ex);
        }
        finally
        {
            binReader.Close();
        }
    }

    /// <summary>
    ///     As it stands, the native byte order in .pbm, .pgm, and .ppm images is BGR.  We need to reverse the order
    ///     into RGB as this is what is needed for 24bppRGB  bitmap pixel format on Windows.
    /// </summary>
    private void ReorderBGRtoRGB()
    {
        var tempData = new byte[ImageData.Length];
        for (var i = 0; i < ImageData.Length; i++) tempData[i] = ImageData[ImageData.Length - 1 - i];
        ImageData = tempData;
    }

    /// <summary>
    ///     This struct contains the objects that are found in the header of .pbm, .pgm, and .ppm files.
    /// </summary>
    [Serializable]
    public struct PixelMapHeader
    {
        private string magicNumber;

        /// <summary>
        ///     The "Magic Number" that identifies the type of Pixelmap. P1 = PBM (ASCII); P2 = PGM (ASCII); P3 = PPM (ASCII); P4
        ///     is not used;
        ///     P5 = PGM (Binary); P6 = PPM (Binary).
        /// </summary>
        public string MagicNumber
        {
            get => magicNumber;
            set => magicNumber = value;
        }

        private int width;

        /// <summary>
        ///     The width of the image.
        /// </summary>
        public int Width
        {
            get => width;
            set => width = value;
        }

        private int height;

        /// <summary>
        ///     The height of the image.
        /// </summary>
        public int Height
        {
            get => height;
            set => height = value;
        }

        private int depth;

        /// <summary>
        ///     The depth (maximum color value in each channel) of the image.  This allows the format to represent
        ///     more than a single byte (0-255) for each color channel.
        /// </summary>
        public int Depth
        {
            get => depth;
            set => depth = value;
        }
    }
}